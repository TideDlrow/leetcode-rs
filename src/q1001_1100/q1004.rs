///给定一个由若干 0 和 1 组成的数组A，我们最多可以将K个值从 0 变成 1 。
///
/// 返回仅包含 1 的最长（连续）子数组的长度。
///
///
///
/// 示例 1：
///
/// 输入：A = [1,1,1,0,0,0,1,1,1,1,0], K = 2
/// 输出：6
/// 解释：
/// [1,1,1,0,0,1,1,1,1,1,1]
/// 粗体数字从 0 翻转到 1，最长的子数组长度为 6。
/// 示例 2：
///
/// 输入：A = [0,0,1,1,0,0,1,1,1,0,1,1,0,0,0,1,1,1,1], K = 3
/// 输出：10
/// 解释：
/// [0,0,1,1,1,1,1,1,1,1,1,1,0,0,0,1,1,1,1]
/// 粗体数字从 0 翻转到 1，最长的子数组长度为 10。
///
///
/// 提示：
///
/// 1 <= A.length <= 20000
/// 0 <= K <= A.length
/// A[i] 为0或1
///
pub fn longest_ones(a: Vec<i32>, k: i32) -> i32 {
    //解题思路
    // 重点：题意转换。把「最多可以把 K 个 0 变成 1，求仅包含 1 的最长子数组的长度」转换为 「找出一个最长的子数组，该子数组内最多允许有 K 个 0 」。
    // 经过上面的题意转换，我们可知本题是求最大连续子区间，可以使用滑动窗口方法。滑动窗口的限制条件是：窗口内最多有 K 个 0。
    //
    // 可以使用我多次分享的滑动窗口模板解决，模板在代码之后。
    //
    // 代码思路：
    //
    // 使用 leftleft 和 rightright 两个指针，分别指向滑动窗口的左右边界。
    // rightright 主动右移：rightright 指针每次移动一步。当 A[right]A[right] 为 00，说明滑动窗口内增加了一个 00；
    // leftleft 被动右移：判断此时窗口内 00 的个数，如果超过了 KK，则 leftleft 指针被迫右移，直至窗口内的 00 的个数小于等于 KK 为止。
    // 滑动窗口长度的最大值就是所求。

    let mut res = 0;
    let mut zeros = 0;
    let mut left = 0;
    for right in 0..a.len() {
        if a[right] == 0 {
            zeros += 1;
        }
        while zeros > k {
            if a[left] == 0 {
                zeros -= 1;
            }
            left += 1;
        }
        res = std::cmp::max(res, right - left + 1);
    }
    res as i32
}

#[test]
fn test() {
    println!("{}", longest_ones(vec![1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 0], 2));
}
