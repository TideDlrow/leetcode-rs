use std::collections::HashMap;

///森林中，每个兔子都有颜色。其中一些兔子（可能是全部）告诉你还有多少其他的兔子和自己有相同的颜色。我们将这些回答放在 answers 数组里。
///
/// 返回森林中兔子的最少数量。
///
/// 示例:
/// 输入: answers = [1, 1, 2]
/// 输出: 5
/// 解释:
/// 两只回答了 "1" 的兔子可能有相同的颜色，设为红色。
/// 之后回答了 "2" 的兔子不会是红色，否则他们的回答会相互矛盾。
/// 设回答了 "2" 的兔子为蓝色。
/// 此外，森林中还应有另外 2 只蓝色兔子的回答没有包含在数组中。
/// 因此森林中兔子的最少数量是 5: 3 只回答的和 2 只没有回答的。
///
/// 输入: answers = [10, 10, 10]
/// 输出: 11
///
/// 输入: answers = []
/// 输出: 0
/// 说明:
///
/// answers 的长度最大为1000。
/// answers[i] 是在 [0, 999] 范围内的整数。
///
///
/// 解题思路
// 重点：当某个兔子回答 x 的时候，那么数组中最多允许 x+1 个同花色的兔子🐰同时回答 x。
//
// 我们先举个例子进行理解：
//
// 比如有一个红色的兔子回答了 2，那么数组中最多有 3 个红色的兔子。
// 如果数组是 [2,2,2] ，那么至少有一种颜色的兔子。
// 如果数组是 [2,2,2,2] ，那么说明至少有两种颜色的兔子，比如说前 3 个兔子构成一种颜色；那么最后一个兔子说的必须是其他颜色。
// 如果数组是 [2,2,2,2,2,2] ，那么说明至少有两种颜色的兔子，比如说前 3 个兔子构成一种颜色；那么后 3 个兔子说的必须是其他颜色。
// 通过上面的这个例子可以得出以下的规律。
//
// 我们统计数组中所有回答 xx 的兔子的数量 nn：
//
// 若 n % (x+1)==0，说明我们此时只需要 n/(x+1)n/(x+1) 种不同颜色的兔子，每种颜色兔子的个数为 x+1x+1 。
// 若 n % (x+1) != 0，说明我们此时只需要 n/(x+1) + 1n/(x+1)+1 种不同颜色的兔子，每种颜色兔子的个数为 x+1x+1 。
// 那么这两种情况可以通过 ceil(n/(x+1))ceil(n/(x+1)) 来整合（其中 ceil()ceil() 是向上取整函数），即 n / (x + 1)n/(x+1) 向上取整 种不同颜色的兔子。 向上取整的函数可以自己实现，也可以转化为 (n + x) / (x + 1)(n+x)/(x+1)，这个公式中的除法是 向下取整。证明在代码后面。
//
// 我们还把上面的例子拿来，看一下计算的对不对。
//
// 如果数组是 [2,2,2] ，那么有 ceil(n/(x+1)) = ceil(3/3) = 1ceil(n/(x+1))=ceil(3/3)=1 种颜色的兔子，也可以通过 (n + x) / (x + 1) = (3 + 2) / (2 + 1) = 1(n+x)/(x+1)=(3+2)/(2+1)=1 计算得到。
// 如果数组是 [2,2,2,2] ，那么有 ceil(n/(x+1)) = ceil(4/3) = 2ceil(n/(x+1))=ceil(4/3)=2 种颜色的兔子，也可以通过 (n + x) / (x + 1) = (4 + 2) / (2 + 1) = 2(n+x)/(x+1)=(4+2)/(2+1)=2 计算得到。
// 如果数组是 [2,2,2,2,2,2] ，那么有 ceil(n/(x+1)) = ceil(6/3) = 2ceil(n/(x+1))=ceil(6/3)=2 种颜色的兔子，也可以通过 (n + x) / (x + 1) = (6 + 2) / (2 + 1) = 2(n+x)/(x+1)=(6+2)/(2+1)=2 计算得到。
//
// 作者：fuxuemingzhu
// 链接：https://leetcode-cn.com/problems/rabbits-in-forest/solution/fu-xue-ming-zhu-zhao-gui-lu-fu-xiang-sha-1yk3/
// 来源：力扣（LeetCode）
// 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
pub fn num_rabbits(answers: Vec<i32>) -> i32 {
    let mut res = 0;
    let mut m = HashMap::new();
    for i in 0..answers.len() {
        let a = answers[i];
        if let Some(v) = m.get_mut(&a) {
            *v += 1;
        } else {
            m.insert(answers[i], 1);
        }
    }
    for (key, value) in m.iter() {
        res += (key + value) / (key + 1) * (key + 1);
    }
    res
}

#[test]
fn test() {
    println!("{}", num_rabbits(vec![1, 1, 2]));
}
