///给定一个 m x n 的矩阵，如果一个元素为 0 ，则将其所在行和列的所有元素都设为 0 。请使用 原地 算法。
///
/// 进阶：
///
/// 一个直观的解决方案是使用  O(mn) 的额外空间，但这并不是一个好的解决方案。
/// 一个简单的改进方案是使用 O(m + n) 的额外空间，但这仍然不是最好的解决方案。
/// 你能想出一个仅使用常量空间的解决方案吗？
///  
///
/// 示例 1：
///
///
/// 输入：matrix = [[1,1,1],[1,0,1],[1,1,1]]
/// 输出：[[1,0,1],[0,0,0],[1,0,1]]
/// 示例 2：
///
///
/// 输入：matrix = [[0,1,2,0],[3,4,5,2],[1,3,1,5]]
/// 输出：[[0,0,0,0],[0,4,5,0],[0,3,1,0]]
///  
///
/// 提示：
///
/// m == matrix.length
/// n == matrix[0].length
/// 1 <= m, n <= 200
/// -2^31 <= matrix[i][j] <= 2^31 - 1
///
/// 法一：
/// 用两个数组记录每一行和每一列是否有零出现
///具体地，我们首先遍历该数组一次，如果某个元素为 0，那么就将该元素所在的行和列所对应标记数组的位置置为 true。最后我们再次遍历该数组，用标记数组更新原数组即可。
///
/// 法二：
/// 我们可以用矩阵的第一行和第一列代替方法一中的两个标记数组，
/// 以达到 O(1) 的额外空间。但这样会导致原数组的第一行和第一列被修改，无法记录它们是否原本包含 0。
/// 因此我们需要额外使用两个标记变量分别记录第一行和第一列是否原本包含 0。
///
pub fn set_zeroes(matrix: &mut Vec<Vec<i32>>) {
    //行数
    let m = matrix.len();
    //列数
    let n = matrix[0].len();
    let (mut flag_col0, mut flag_row0) = (false, false);
    //判断第一列是否存在0
    for i in 0..m {
        if matrix[i][0] == 0 {
            flag_col0 = true;
        }
    }
    //第一行是否存在0
    for i in 0..n {
        if matrix[0][i] == 0 {
            flag_row0 = true;
        }
    }
    //用矩阵第一行和第一列记录每行是否存在0
    for i in 1..m {
        for j in 1..n {
            if matrix[i][j] == 0 {
                matrix[i][0] = 0;
                matrix[0][j] = 0;
            }
        }
    }
    //根据记录的值去更改其他值
    for i in 1..m {
        for j in 1..n {
            if matrix[i][0] == 0 || matrix[0][j] == 0 {
                matrix[i][j] = 0;
            }
        }
    }
    if flag_col0 {
        for i in 0..m {
            matrix[i][0] = 0;
        }
    }
    if flag_row0 {
        for j in 0..n {
            matrix[0][j] = 0;
        }
    }
}

#[test]
fn test() {
    let mut m = vec![
        vec![0, 1, 2, 0],
        vec![3, 4, 5, 2],
        vec![1, 3, 1, 5]
    ];
    set_zeroes(&mut m);
    println!("{:?}", &m);
}
